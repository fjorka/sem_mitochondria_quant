"""
Processes raw mitochondria masks generated by SAM, filters them based on axon
location and properties, classifies them using a FastAI model, and saves the
final results to a DataFrame.
"""

import argparse
import os
import sys
import time
import gc
import pickle as pkl
import warnings
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple

import dask.array as da
import numpy as np
import pandas as pd
import torch
from loguru import logger
from skimage.color import gray2rgb
from tifffile import imread
from tqdm import tqdm

# --- Import shared components ---
try:
    from sem_quant.utils import setup_logging, smart_path
    from sem_quant.load_config import load_config, PipelineConfig
    from sem_quant.data_utils import load_image_dask
    from sem_quant.processing_utils import (
        extract_regionprops,
        suppress_by_iou_mitos,
    )
    UTILS_AVAILABLE = True
except ImportError as e:
    print(f"Error: Could not import necessary functions. "
            f"Please ensure 'utils.py', 'load_config.py', 'data_utils.py', "
            f"and 'processing_utils.py' are accessible. "
            f"Error: {e}")
    UTILS_AVAILABLE = False

# --- Constants ---
LOGS_SUBDIR = 'logs'
# Define region properties needed (as used in the notebook)
REGION_PROPS = ['label','area', 'area_convex', 'area_filled', 'euler_number', 'image', 'bbox',
                'eccentricity', 'solidity', 'centroid', 'major_axis_length', 'minor_axis_length']
ANNOTATION_SUFFIX = ".pkl"
UNCLASSIFIED_SUFFIX = "_unclassified"

# --- Function Definitions ---

def process_single_axon_mitos(
    axon_row: pd.Series,
    config: PipelineConfig,
) -> Optional[pd.DataFrame]:
    """
    Loads raw mito masks for a single axon, filters, extracts properties,
    and adjusts coordinates.

    Args:
        axon_row: A row from the processed axon DataFrame.
        config: The loaded PipelineConfig object.

    Returns:
        A DataFrame containing processed mitochondria data for the axon, or None if processing fails.
    """
    paths = config.paths
    data_props = config.data_properties
    mitos_filters = config.mitos_filters

    axon_label = axon_row['label']
    mito_mask_filename = f"{paths.output_prefix}{str(axon_label).zfill(6)}_{paths.mitos_data_suffix}{ANNOTATION_SUFFIX}"
    mito_mask_filepath = Path(smart_path(paths.analysis_dir)) / paths.mitos_data_suffix / mito_mask_filename

    res_adjust_power = data_props.axons_res - data_props.mitos_res
    res_adjust_factor = 2**res_adjust_power

    if not mito_mask_filepath.exists():
        logger.warning(f"Mito mask file not found for axon {axon_label}: {mito_mask_filepath}")
        return None

    try:
        # Load raw masks for this axon
        with open(mito_mask_filepath, 'rb') as f:
            masks_raw = pkl.load(f)

        if not masks_raw or not isinstance(masks_raw, list):
             logger.info(f"No valid masks found in file for axon {axon_label}.")
             return None

        # Get the axon's interior mask (at the resolution from axon processing)
        # Ensure inside_mask is boolean
        inside_mask = axon_row['inside_image'].astype(bool)
        if inside_mask.ndim != 2:
             logger.error(f"Invalid 'inside_mask' dimensions ({inside_mask.shape}) for axon {axon_label}. Skipping.")
             return None


        # Filter mitos: Keep only those whose point_coords fall within the axon interior
        masks_inside_axon = []
        for mask_data in masks_raw:
             if 'point_coords' in mask_data and mask_data['point_coords']:
                 center_y_local = mask_data['point_coords'][0][1] # Usually [y, x] in skimage/numpy
                 center_x_local = mask_data['point_coords'][0][0]
             else:
                 logger.warning(f"Mask for axon {axon_label} missing center coordinate info. Skipping mask.")
                 continue

             # Scale mito coordinates *down* to axon resolution
             center_y_axon_res = int(center_y_local / res_adjust_factor)
             center_x_axon_res = int(center_x_local / res_adjust_factor)

             # Check bounds against the inside_mask shape
             if inside_mask[center_y_axon_res, center_x_axon_res]:
                masks_inside_axon.append(mask_data)


        if not masks_inside_axon:
            logger.info(f"No mitochondria masks found inside axon {axon_label}.")
            return None

        df_masks = pd.DataFrame(masks_inside_axon)

        # --- Filter based on SAM metrics (Area, predicted IoU) ---
        area_min = mitos_filters.min_area
        area_max = mitos_filters.max_area
        iou_min = mitos_filters.min_iou

        df_filtered = df_masks[
            (df_masks['area'] > area_min) &
            (df_masks['area'] < area_max) &
            (df_masks['predicted_iou'] > iou_min)
        ].copy() # Use copy to avoid SettingWithCopyWarning

        if df_filtered.empty:
            logger.info(f"No masks passed SAM metric filters for axon {axon_label}.")
            return None
        logger.debug(f"Axon {axon_label}: {len(df_filtered)} masks passed SAM metric filters.")

        # --- Extract Region Properties ---
        props_list = []
        for _, row_mito in df_filtered.iterrows():
            # extract_regionprops expects 'bbox' and 'segmentation'
            # The 'bbox' from SAM is [x,y,w,h], regionprops needs [min_row, min_col, max_row, max_col]
            # 'segmentation' is the bool mask itself.
            # extract_regionprops handles the conversion and coordinate adjustment internally *relative to the mask's bbox*
            try:
                props = extract_regionprops(row_mito, REGION_PROPS, small_size=area_min)
                if not props.empty:
                     props['origin_sam_index'] = row_mito.name # Keep track of original SAM mask index
                     props_list.append(props)
            except Exception as e_rp:
                 logger.warning(f"Could not extract regionprops for a mask in axon {axon_label}. Error: {e_rp}")
                 continue # Skip this mask

        if not props_list:
            logger.info(f"No valid regionprops extracted for axon {axon_label}.")
            return None

        df_props = pd.concat(props_list, ignore_index=True)

        # Rename area column to avoid conflict
        df_props.rename(columns={'area': 'mito_area'}, inplace=True)
        # Ensure 'image' column contains numpy arrays
        df_props['image'] = df_props['image'].apply(lambda x: np.array(x) if not isinstance(x, np.ndarray) else x)

        # Merge SAM data with regionprops data
        df_merged = pd.merge(df_filtered, df_props, left_on=df_filtered.index, right_on='origin_sam_index', how='right')
        if df_merged.empty:
             logger.warning(f"Merge failed between SAM masks and regionprops for axon {axon_label}.")
             return None

        # --- Filter by Eccentricity ---
        max_ecc = mitos_filters.max_eccentricity
        df_final = df_merged[df_merged['eccentricity'] < max_ecc].copy()

        if df_final.empty:
            logger.info(f"No masks passed eccentricity filter for axon {axon_label}.")
            return None
        logger.debug(f"Axon {axon_label}: {len(df_final)} masks passed eccentricity filter.")

        # --- Suppress by IoU ---
        # suppress_by_iou_mitos expects ['bbox-0', 'bbox-1', 'bbox-2', 'bbox-3'] and 'eccentricity'
        df_final = suppress_by_iou_mitos(df_final.reset_index(drop=True), iou_threshold=mitos_filters.iou_threshold)
        df_final = df_final[df_final['keep'] == 1].reset_index(drop=True)

        if df_final.empty:
            logger.info(f"No masks remaining after IoU suppression for axon {axon_label}.")
            return None
        logger.debug(f"Axon {axon_label}: {len(df_final)} masks remaining after IoU suppression.")

        # --- Adjust Coordinates to Full Image Space ---
        # Get the top-left corner of the axon's *inside* region in the full mito-resolution image
        row_start_abs = int((axon_row['inside_bbox-0'] + data_props.row_offset) * res_adjust_factor)
        col_start_abs = int((axon_row['inside_bbox-1'] + data_props.col_offset) * res_adjust_factor)

        # Add this offset to the mito coordinates (which are relative to the extracted axon region)
        for col in ['bbox-0', 'bbox-2', 'centroid-0']:
            df_final[col] = df_final[col] + row_start_abs
        for col in ['bbox-1', 'bbox-3', 'centroid-1']:
            df_final[col] = df_final[col] + col_start_abs

        # Assign cell label
        df_final['cell_label'] = axon_label

        # Drop temporary/unneeded columns
        # Keep 'image' for classification cropping if needed later
        cols_to_drop = ['segmentation', 'area', 'keep'] # 'area' is SAM area, 'mito_area' is regionprops area
        df_final.drop(columns=[col for col in cols_to_drop if col in df_final.columns], inplace=True)

        return df_final

    except Exception as e:
        logger.error(f"Failed processing axon {axon_label}: {e}", exc_info=True)
        return None

# --- Main ---

def run_mitos_processing(config: str):
    """
    Main processing pipeline for mitos masks.

    Args:
        config: Loaded pipeline configuration object.
    """

    # time to log duration of execution
    start_time = time.time()

    # --- Setup Paths and Parameters ---
    try:
        paths = config.paths
        data_props = config.data_properties
        mitos_filters = config.mitos_filters
        mitos_classifier = config.mitos_classifier

        analysis_dir = Path(smart_path(paths.analysis_dir))
        raw_mito_masks_dir = analysis_dir / paths.mitos_data_suffix
        im_path = Path(paths.im_path)

        # Load axon data
        axon_data_filename = f"{paths.output_prefix}{paths.axons_data_suffix}{ANNOTATION_SUFFIX}"
        axon_data_path = analysis_dir / axon_data_filename
        logger.info(f"Loading processed axon data from: {axon_data_path}")
        if not axon_data_path.exists():
             logger.error(f"Axon data file not found: {axon_data_path}")
             return
        df_axons = pd.read_pickle(axon_data_path)

    except Exception as e:
        logger.error(f"Error during setup phase: {e}", exc_info=True)
        return

    # --- Process Masks for Each Axon ---
    processed_mito_dfs = []
    processed_axons = 0
    skipped_axons = 0

    logger.info("Starting processing loop for each axon...")
    for _, axon_row in tqdm(df_axons.iterrows(), total=len(df_axons), desc="Processing Axons"):

        df_processed = process_single_axon_mitos(
            axon_row, config
        )

        if df_processed is not None and not df_processed.empty:
            processed_mito_dfs.append(df_processed)
            processed_axons += 1
        else:
            skipped_axons += 1
        
    logger.info(f"Finished processing loop. Axons processed: {processed_axons}, Axons skipped: {skipped_axons}")

    if not processed_mito_dfs:
        logger.error("No mitochondria were processed successfully. Exiting.")
        return

    # --- Combine  ---
    try:
        logger.info("Concatenating results...")
        df_mitos_all = pd.concat(processed_mito_dfs, ignore_index=True)
        # Assign unique labels to all mitochondria across all axons
        df_mitos_all['label'] = df_mitos_all.index + 1
        logger.info(f"Total mitochondria found: {len(df_mitos_all)}")
    except Exception as e:
        logger.error(f"Error during final concatenation: {e}", exc_info=True)
        return

    # --- Save ---

    try:
        output_filename = paths.output_prefix + paths.mitos_data_suffix + UNCLASSIFIED_SUFFIX + ANNOTATION_SUFFIX
        output_path = analysis_dir / output_filename
        logger.info(f"Saving final processed mitochondria DataFrame to: {output_path}")
        df_mitos_all.to_pickle(output_path)

    except Exception as e:
        logger.error(f"Error during saving: {e}", exc_info=True)


    end_time = time.time()
    logger.info(f"Total execution time: {end_time - start_time:.2f} seconds")
    logger.info("--- Mitochondria Processing Script Finished ---")

# --- Main Execution ---

if __name__ == "__main__":
    
    # --- Argument Parsing ---
    parser = argparse.ArgumentParser(description="Process mitos...")
    parser.add_argument("config_path", type=str, help="Path to config JSON.")
    args = parser.parse_args()

    # --- Load Config ---
    try:
        print(f"Loading configuration from: {args.config_path}")
        config = load_config(args.config_path)
    except Exception as e:
        print(f"FATAL: Failed to load configuration '{args.config_path}': {e}")
        exit(1)

    # --- Setup Logging using Config ---
    try:
        analysis_dir = Path(smart_path(config.paths.analysis_dir))
        log_dir = analysis_dir / LOGS_SUBDIR
        log_file_path = log_dir / f"process_mitos_{{time}}.log"
    except Exception as e:
         print(f"WARNING: Error determining log path from config: {e}.")
         exit(1)

    setup_logging(log_file_path=log_file_path)

    # --- Run Main Logic ---
    try:
        run_mitos_processing(config) # Pass the loaded config
    except Exception as e:
        logger.exception("Pipeline step failed with an unhandled exception.")

    # --- Successful Exit ---
    sys.exit(0)