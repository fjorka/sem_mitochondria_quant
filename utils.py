import dask.array as da
import pandas as pd
import numpy as np
from itertools import combinations

from skimage.measure import label,regionprops_table, regionprops
from skimage.morphology import remove_small_holes, remove_small_objects, disk
from skimage.morphology import remove_small_holes
from scipy.ndimage import binary_fill_holes


def tile_image(image, tile_size_x=1024, tile_size_y=1024, tile_overlap_x=300, tile_overlap_y=300):
    """
    Tiles an image into overlapping patches.
    
    Args:
        image (np.ndarray): The input image (H, W, C) or (H, W).
        tile_size_x (int): Width of each tile.
        tile_size_y (int): Height of each tile.
        tile_overlap_x (int): Overlap between tiles horizontally.
        tile_overlap_y (int): Overlap between tiles vertically.
        
    Returns:
        tiles (list of np.ndarray): List of image tiles.
        coords (list of tuple): List of (x_start, y_start, x_end, y_end) for each tile.
    """
    tiles = []
    coords = []

    H, W = image.shape[:2]

    stride_x = tile_size_x - tile_overlap_x
    stride_y = tile_size_y - tile_overlap_y

    for y in range(0, H, stride_y):
        for x in range(0, W, stride_x):
            x_start = x
            y_start = y
            x_end = min(x + tile_size_x, W)
            y_end = min(y + tile_size_y, H)

            # Adjust start if we're at the edge and the tile is smaller
            if x_end - x_start < tile_size_x:
                x_start = max(0, W - tile_size_x)
                x_end = W
            if y_end - y_start < tile_size_y:
                y_start = max(0, H - tile_size_y)
                y_end = H

            tile = image[y_start:y_end, x_start:x_end]
            tiles.append(tile)
            coords.append((x_start, y_start, x_end, y_end))

    return tiles, coords

def extract_regionprops(row,properties,small_size = 100):
    """
    Extracts region properties from a segmentation mask.

    This function processes a segmentation mask extracted from a bounding box 
    in a single row of a dataframe (e.g., generated by the Segment Anything Model).
    It removes small objects and holes, labels distinct regions, and calculates
    region properties for each individual object.

    Parameters
    ----------
    row : pandas.Series
        A row from a dataframe containing 'bbox' and 'segmentation' keys.
        'bbox' should be a list or array [x, y, width, height].
        'segmentation' should be a 2D boolean numpy array representing the mask.
    
    properties : list of str
        A list of region property names to extract, passed to `regionprops_table`
        from `skimage.measure`.

    small_size : int, optional
        Minimum size (in pixels) for an object or hole to be retained during
        morphological cleaning (default is 100).

    Returns
    -------
    pandas.DataFrame
        A dataframe where each row corresponds to a labeled object in the 
        segmentation mask, with columns corresponding to the requested region 
        properties (e.g., area, centroid, bounding box). Coordinates are adjusted 
        relative to the full image space.
    """
    
    # get bounding box
    pad_size = 5
    bbox = [int(x) for x in row['bbox']]
    im_mask = row['segmentation'][bbox[1]:bbox[1]+bbox[3],bbox[0]:bbox[0]+bbox[2]]
    im_mask_1 = remove_small_objects(im_mask, min_size=small_size, connectivity=1)
    padded = np.pad(im_mask_1, pad_width=pad_size, mode='constant', constant_values=False)
    im_mask_2 = remove_small_holes(padded, area_threshold=small_size, connectivity=1)
    im_mask_2 = im_mask_2[5:-5, 5:-5]
    im_mask_clean = label(im_mask_2)
    
    props = pd.DataFrame(regionprops_table(im_mask_clean, properties=properties))

    props['bbox-0'] = props['bbox-0'] + bbox[1]
    props['bbox-1'] = props['bbox-1'] + bbox[0]
    props['bbox-2'] = props['bbox-2'] + bbox[1]
    props['bbox-3'] = props['bbox-3'] + bbox[0]

    props['centroid-0'] = props['centroid-0'] + bbox[1]
    props['centroid-1'] = props['centroid-1'] + bbox[0]

    bbox_cols = ['bbox-0', 'bbox-1', 'bbox-2', 'bbox-3']
    props[bbox_cols] = props[bbox_cols].astype(int)
    
    # Each regionprops_table output is a dictionary 
    return props

def compute_iou_array(box1, box2):
    """
    Computes the Intersection over Union (IoU) between two bounding boxes.

    The IoU is a measure of the overlap between two bounding boxes and is 
    defined as the area of their intersection divided by the area of their union.

    Parameters
    ----------
    box1 : array-like of float or int
        The first bounding box in the format (min_row, min_col, max_row, max_col).
    
    box2 : array-like of float or int
        The second bounding box in the same format as `box1`.

    Returns
    -------
    float
        The IoU value between the two bounding boxes. A value between 0 and 1, 
        where 0 means no overlap and 1 means perfect overlap. Returns 0 if the 
        union area is zero.
    """

    # Format: (min_row, min_col, max_row, max_col)
    y1_min, x1_min, y1_max, x1_max = box1
    y2_min, x2_min, y2_max, x2_max = box2

    inter_ymin = max(y1_min, y2_min)
    inter_xmin = max(x1_min, x2_min)
    inter_ymax = min(y1_max, y2_max)
    inter_xmax = min(x1_max, x2_max)

    inter_area = max(0, inter_ymax - inter_ymin) * max(0, inter_xmax - inter_xmin)

    area1 = (y1_max - y1_min) * (x1_max - x1_min)
    area2 = (y2_max - y2_min) * (x2_max - x2_min)

    union_area = area1 + area2 - inter_area

    return inter_area / union_area if union_area > 0 else 0

def suppress_by_iou(df, iou_threshold = 0.5):
    """
    Suppresses overlapping objects based on Intersection over Union (IoU) and solidity.

    This function is designed for the detection of myelinated axons, where ring-shaped 
    structures (identified by their Euler number) should not be suppressed by solid objects. 
    The function compares all object pairs, and for each pair with IoU above a given threshold, 
    it suppresses one of the objects based on solidity and topology (ring vs. non-ring).

    Parameters
    ----------
    df : pandas.DataFrame
        A dataframe containing at least the following columns:
        - 'bbox-0', 'bbox-1', 'bbox-2', 'bbox-3' : Bounding box coordinates 
          in (min_row, min_col, max_row, max_col) format.
        - 'solidity' : Object solidity score used for prioritization.
        - 'euler_number' : Topological feature used to distinguish ring-shaped objects.

    iou_threshold : float, optional
        The IoU threshold above which overlapping objects are considered for suppression 
        (default is 0.5).

    Returns
    -------
    pandas.DataFrame
        A copy of the input dataframe with an additional column `'keep'` indicating 
        whether each object should be retained (`1`) or suppressed (`0`).
    """
    
    df = df.copy()
    df['keep'] = 1  # Default to keep everything

    bboxes = df[['bbox-0', 'bbox-1', 'bbox-2', 'bbox-3']].values
    scores = df['solidity'].values
    eulers = df['euler_number'].values

    for i, j in combinations(range(len(df)), 2):
        iou = compute_iou_array(bboxes[i], bboxes[j])
        
        if iou > iou_threshold:
            i_ring = eulers[i] < 1
            j_ring = eulers[j] < 1

            if i_ring and not j_ring:
                df.at[j, 'keep'] = 0
            elif j_ring and not i_ring:
                df.at[i, 'keep'] = 0
            else:
                if scores[i] >= scores[j]:
                    df.at[i, 'keep'] = 0
                else:
                    df.at[j, 'keep'] = 0

    return df

def suppress_by_iou_mitos(df, iou_threshold = 0.5):
    """
    Suppresses overlapping segmented mitochondria based on IoU and eccentricity.

    This function is used to reduce redundancy in object detection results for 
    mitochondria by suppressing overlapping detections. For each pair of objects 
    with an Intersection over Union (IoU) greater than the specified threshold, 
    the one with lower eccentricity is retained, under the assumption that 
    mitochondria are typically elongated and thus more eccentric.

    Parameters
    ----------
    df : pandas.DataFrame
        A dataframe containing at least the following columns:
        - 'bbox-0', 'bbox-1', 'bbox-2', 'bbox-3' : Bounding box coordinates 
          in (min_row, min_col, max_row, max_col) format.
        - 'eccentricity' : Eccentricity values of the segmented objects, used 
          as a priority metric for retention.

    iou_threshold : float, optional
        The IoU threshold above which overlapping objects are considered 
        for suppression (default is 0.5).

    Returns
    -------
    pandas.DataFrame
        A copy of the input dataframe with an additional column `'keep'` 
        indicating whether each object should be retained (`1`) or suppressed (`0`).
    """
    
    df = df.copy()
    df['keep'] = 1  # Default to keep everything

    bboxes = df[['bbox-0', 'bbox-1', 'bbox-2', 'bbox-3']].values
    scores = df['eccentricity'].values

    for i, j in combinations(range(len(df)), 2):
        iou = compute_iou_array(bboxes[i], bboxes[j])
        
        if iou > iou_threshold:

            if scores[i] <= scores[j]:
                df.at[i, 'keep'] = 0
            else:
                df.at[j, 'keep'] = 0

    return df

def mask_from_df(df, shape, prefix=''):
    """
    Generates a labeled mask from a dataframe containing regionprops-style information.

    This function reconstructs a full-sized labeled mask from region-level 
    information (e.g., bounding boxes and corresponding subregion masks) typically 
    produced by `regionprops_table`. It places each labeled object at its correct 
    location in the full image.

    Parameters
    ----------
    df : pandas.DataFrame
        A dataframe with region-level data. Expected to contain at least the following 
        columns, optionally prefixed:
        - '<prefix>bbox-0', '<prefix>bbox-1', '<prefix>bbox-2', '<prefix>bbox-3' : 
          Bounding box coordinates (min_row, min_col, max_row, max_col).
        - '<prefix>image' : A 2D boolean or integer array representing the object mask 
          within its bounding box.
        - '<prefix>label' : An integer label identifying the object.
    
    shape : tuple of int
        The shape (height, width) of the full-size output mask.

    prefix : str, optional
        A string prefix prepended to column names in the dataframe, useful if multiple 
        regionprops outputs are stored in a single dataframe (default is '').

    Returns
    -------
    numpy.ndarray
        A 2D `np.uint16` array of the same shape as `shape`, where each object is 
        placed according to its bounding box and assigned its corresponding label.
    """
    
    mask = np.zeros(shape, dtype=np.uint16)
    for i, row in df.iterrows():
        row_start = int(row[f'{prefix}bbox-0'])
        row_stop = int(row[f'{prefix}bbox-2'])
        col_start = int(row[f'{prefix}bbox-1'])
        col_stop = int(row[f'{prefix}bbox-3'])
        patch = mask[row_start:row_stop, col_start:col_stop]
        mask[row_start:row_stop, col_start:col_stop] = patch + row[f'{prefix}image']*row[f'{prefix}label']
    return mask

def find_edge_df(df_res, im_shape, skip_labels = [], pad_size = 25):
    """
    Identifies and filters edge-associated ring-shaped objects from a segmentation dataframe.

    This function selects segmented objects that touch the edges of an image 
    (within a specified padding) and filters them based on morphological properties 
    to identify candidates resembling cut ring structures. It is especially useful 
    in biological imaging scenarios where partially segmented ring-like structures 
    (e.g., myelin rings at the image boundary) need special handling.

    Parameters
    ----------
    df_res : pandas.DataFrame
        A dataframe containing segmentation results. Must include:
        - 'keep' : Binary flag indicating whether the object should be retained.
        - 'bbox-0' to 'bbox-3' : Bounding box coordinates in the format 
          (min_row, min_col, max_row, max_col).
        - 'label' : Unique object identifier.
        - 'image' : 2D binary mask (numpy array) representing the object.

    im_shape : tuple of int
        Shape of the full image, given as (height, width).

    skip_labels : list of int, optional
        List of labels to be excluded from edge analysis (default is an empty list).

    pad_size : int, optional
        Margin (in pixels) used to define proximity to image edges (default is 25).

    Returns
    -------
    pandas.DataFrame
        A filtered dataframe containing only the detected edge-associated ring-like 
        objects. Each row includes an additional column:
        - 'edge_side' : Which image edge the object touches ('top', 'bottom', 'left', 'right').
        - 'edge_ring' : Boolean indicating whether the object's morphology matches that 
          of a cut ring (Euler number < 1, substantial unfilled area).
    """

    df_edge = df_res.loc[df_res.keep == 1,:]
    df_edge.loc[df_edge['bbox-0'] < pad_size,'edge_side'] = 'top'
    df_edge.loc[df_edge['bbox-1'] < pad_size,'edge_side'] = 'left'
    df_edge.loc[df_edge['bbox-2'] > (im_shape[0]-pad_size),'edge_side'] = 'bottom'
    df_edge.loc[df_edge['bbox-3'] > (im_shape[1]-pad_size),'edge_side'] = 'right'

    # drop non-edge
    df_edge = df_edge.loc[df_edge['edge_side'].notnull(),:]
    # drop if appears in df_sel
    df_edge = df_edge.loc[~df_edge['label'].isin(skip_labels),:]

    # drop if the area doesn't resemble a cut ring
    for ind,row in df_edge.iterrows():

        candidate_mask = row.image.astype(np.uint8).copy()

        if row.edge_side == 'left':
            candidate_mask[:,:5] = 1
        elif row.edge_side == 'top':
            candidate_mask[:5,:] = 1
        elif row.edge_side == 'right':
            candidate_mask[:,-5:] = 1    
        elif row.edge_side == 'bottom':
            candidate_mask[-5:,:] = 1
            
        prop = regionprops(candidate_mask)
        df_edge.loc[ind, 'edge_ring'] = ((prop[0]['euler_number'] < 1) & (prop[0]['area']/prop[0]['area_filled'] < 0.9) & (prop[0]['area_filled'] - prop[0]['area'] > 500))

    df_edge = df_edge.loc[df_edge.edge_ring == True,:]

    return df_edge

def add_soma_data(df, inside_props, pad = 3):
    """
    Adds soma-related region properties to axonal ring-like objects in a segmentation dataframe.

    This function identifies the interior area of ring-shaped objects (representing axons) by 
    filling the ring and extracting the "soma" or central part. It corrects for edge artifacts 
    in partial rings (those touching image borders), extracts region properties from the 
    inside region, and appends the relevant measurements to the dataframe.

    Parameters
    ----------
    df : pandas.DataFrame
        A dataframe with segmented ring-like objects. Must include:
        - 'image' : 2D binary mask (numpy array) of the object.
        - 'bbox-0' to 'bbox-3' : Bounding box coordinates of the object.
        - 'edge_ring' : Boolean indicating if the object is a cut ring on the image edge.
        - 'edge_side' : Side of the image touched by the object ('top', 'bottom', 'left', 'right').

    inside_props : list of str
        A list of region properties to extract from the filled interior region using 
        `skimage.measure.regionprops`.

    pad : int, optional
        Number of pixels to adjust when removing artifacts from edge-corrected masks 
        (default is 3).

    Returns
    -------
    pandas.DataFrame
        A modified dataframe that includes:
        - 'inside_image' : The binary mask of the inner soma region for each object.
        - 'inside_bbox-0' to 'inside_bbox-3' : Bounding box of the inside region, relative to the full image.
        - 'inside_<property>' : Computed region properties (e.g., area, centroid) from the inside region.
    """

    # empty column to keep images
    df['inside_image'] = None
    df['inside_image'] = df['inside_image'].astype(object)

    for ind,row in df.iterrows():
        
        mask = row['image'].copy()
        # pre-process the edge objects
        if row['edge_ring']:
            if row['edge_side'] == 'top':
                mask[:pad,:] = 1
            elif row['edge_side'] == 'bottom':
                mask[-pad:,:] = 1
            elif row['edge_side'] == 'left':
                mask[:,:pad] = 1
            elif row['edge_side'] == 'right':
                mask[:,-pad:] = 1

        
        mask_full = binary_fill_holes(mask)
        mask_inside = mask_full ^ mask

        if row['edge_ring']:
            if row['edge_side'] == 'top':
                mask_inside[:pad,:] = 0
            elif row['edge_side'] == 'bottom':
                mask_inside[-pad:,:] = 0
            elif row['edge_side'] == 'left':
                mask_inside[:,:pad] = 0
            elif row['edge_side'] == 'right':
                mask_inside[:,-pad:] = 0
        
        # collect the inside mask properties
        props = regionprops(label(mask_inside))
        if len(props) > 1:

            props = [max(props, key=lambda x: x.area)]

        if 'image' in inside_props:
            df.at[ind,'inside_image'] = props[0].image

        if 'bbox' in inside_props:
            df.loc[ind,'inside_bbox-0'] = int(props[0].bbox[0] + row['bbox-0'])
            df.loc[ind,'inside_bbox-1'] = int(props[0].bbox[1] + row['bbox-1'])
            df.loc[ind,'inside_bbox-2'] = int(props[0].bbox[2] + row['bbox-0'])
            df.loc[ind,'inside_bbox-3'] = int(props[0].bbox[3] + row['bbox-1'])
        
        if 'centroid' in inside_props:
            df.loc[ind,'inside_centroid-0'] = int(props[0].centroid[0] + row['bbox-0'])
            df.loc[ind,'inside_centroid-1'] = int(props[0].centroid[1] + row['bbox-1'])

        for col in [x for x in inside_props if x not in ['image', 'bbox', 'centroid']]:
            df.loc[ind, f'inside_{col}'] = props[0][col]

    return df

def mark_tile_edge_objects(df, pad=0, filter='all'):
    """
    Flags objects whose bounding boxes are close to the tile boundaries.

    Adds a new boolean column 'tile_edge_object' to the DataFrame, where True indicates 
    that the object's bounding box lies within a specified padding distance from any edge 
    of the tile it resides in. Useful for filtering out objects that may be partially cut off 
    or affected by edge effects in tiled image analysis.

    Parameters:
    -----------
    df : pandas.DataFrame
        A DataFrame containing at least the following columns:
            - 'bbox-0', 'bbox-1', 'bbox-2', 'bbox-3': bounding box (min_row, min_col, max_row, max_col)
            - 'tile_row_start', 'tile_row_end', 'tile_col_start', 'tile_col_end': tile boundaries

    pad : int, optional (default=0)
        The number of pixels to consider as a buffer zone around the tile edges. 
        If any part of the bounding box is within this padding distance of the tile 
        boundary, the object is flagged as being on the edge.

    filter : str, optional (default='all')
        Determines which rows to return:
            - 'all': return all rows with 'tile_edge_object' column
            - 'edge': return only rows where tile_edge_object is True
            - 'not_edge': return only rows where tile_edge_object is False

    Returns:
    --------
    pandas.DataFrame
        The filtered DataFrame, including the 'tile_edge_object' column.

    Raises:
    -------
    ValueError
        If `filter` is not one of {'all', 'edge', 'not_edge'}.

    Example:
    --------
    >>> df = mark_tile_edge_objects(df, pad=5, filter='not_edge')
    >>> len(df)
    # Returns number of non-edge objects
    """
    def is_on_tile_edge(row):
        return (
            row['bbox-0'] <= row['tile_row_start'] + pad or
            row['bbox-2'] >= row['tile_row_end'] - pad or
            row['bbox-1'] <= row['tile_col_start'] + pad or
            row['bbox-3'] >= row['tile_col_end'] - pad
        )

    df['tile_edge_object'] = df.apply(is_on_tile_edge, axis=1)

    if filter == 'all':
        return df
    elif filter == 'edge':
        return df[df['tile_edge_object']].copy()
    elif filter == 'not_edge':
        return df[~df['tile_edge_object']].copy()
    else:
        raise ValueError("Invalid value for filter. Must be one of: 'all', 'edge', 'not_edge'")
    
def extract_cropped_images(df, image, pad=50, prefix=''):
    """
    Extract square image crops centered around specified centroids in a DataFrame.

    For each row in the DataFrame, this function uses the coordinates in the 
    'centroid-0' and 'centroid-1' columns to extract a square region from the 
    input image. The size of the crop is determined by the `pad` value 
    (i.e., crop size = 2 * pad). The resulting cropped image is stored in a new 
    DataFrame column named '{prefix}_image'.

    Parameters:
    ----------
    df : pandas.DataFrame
        DataFrame containing centroid coordinates under 'centroid-0' and 'centroid-1'.
    image : array-like
        2D or ND image array (e.g., a Dask array) from which regions will be extracted.
    pad : int, optional
        Number of pixels to include on each side of the centroid (default is 50).
    prefix : str, optional
        Prefix for the new column name that stores the extracted image regions 
        (default is '', resulting in 'image').

    Returns:
    -------
    df : pandas.DataFrame
        The input DataFrame with an additional column named '{prefix}_image' containing
        the cropped image regions as objects (NumPy arrays).
    """

    # Make sure the column exists and can store arbitrary objects
    df[f'{prefix}_image'] = None
    df[f'{prefix}_image'] = df[f'{prefix}_image'].astype(object)

    for ind, row in df.iterrows():
        row_start = int(row['centroid-0'] - pad)
        row_stop = int(row['centroid-0'] + pad)
        col_start = int(row['centroid-1'] - pad)
        col_stop = int(row['centroid-1'] + pad)

        # Crop and compute image block
        im_object = image[row_start:row_stop, col_start:col_stop].compute()
        
        df.at[ind, f'{prefix}_image'] = im_object

    return df